---
description: 
globs: 
alwaysApply: true
---
---
description: these are the general rules when building this app.
---

* **Component Structure**: All new components should be created within the `components/` directory. Reusable UI components go into `components/ui`, and more complex, feature-specific components go into `components/shared`.
* **API Routes**: Create all backend logic within API routes located in the `app/api/` directory. Follow Next.js App Router conventions for route handlers.
* **Database Migrations**: For any change to the database schema (e.g., creating tables, adding columns, setting up policies), you must write a SQL script. Store all SQL migration scripts in the `supabase/migrations` folder. Each new script should have a timestamp-based name to maintain order.
* **Type Safety**: Generate TypeScript types from your Supabase schema using the Supabase CLI (`npx supabase gen types typescript`). Store these generated types in a dedicated file, like `types/supabase.ts`, and use them throughout the application for type safety.
* **Environment Variables**: **Access all secret keys (like Supabase URL and anon/service keys for local and production) using `process.env`. Create and use `.env.local` for development secrets and manage production secrets securely.**
* **Code Style**: Follow standard TypeScript and React best practices. Use functional components with hooks. Keep components small and focused on a single responsibility.

## Development Environment & Migrations

- All development should use the local Supabase instance. Store your local Supabase URL and anon key in `.env.local` at the project root:

  ```env
  NEXT_PUBLIC_SUPABASE_URL=http://127.0.0.1:54321
  NEXT_PUBLIC_SUPABASE_ANON_KEY=your-local-anon-key
  ```

- Run migrations locally with:
  ```sh
  supabase db push
  ```
- Only push migrations to the remote (production) database when explicitly requested.
- Migration files must be named with the current UTC timestamp: `YYYYMMDDHHMMSS_description.sql`.

## Migration Workflow: Local vs Remote

- **Local Development:**
  - **Always** use the `--local` flag to ensure migrations are applied to your local Docker Supabase database:
    ```sh
    supabase db push --local
    supabase db reset --local
    ```
  - This guarantees all schema changes and migrations affect only your local environment.
  - **Never push migrations to the remote database during development.**

- **Remote (Production) Database:**
  - Only use `supabase db push` (without `--local`) when you are explicitly instructed to update the remote/production database. This should almost never happen and must be requested by the user.
  - The CLI will prompt you to confirm before pushing to remote. Only answer "y" if you are ready for production changes.

- **Best Practice:**
  - Double-check CLI output to ensure you are targeting the correct database before confirming any migration or reset.

---

**Never run migrations on the remote database unless you are explicitly instructed to do so by the user!**

## Migration filename convention (Brisbane time)

YYYYMMDDHHMMSS_<kebab-case-description>.sql

All six numeric fields—year → second—are taken from the current time in the
Australia/Brisbane timezone (AEST, UTC +10, no daylight-saving).

**Regex:** `/^\d{14}_[a-z0-9-]+\.sql$/`

### Example
- `20250608001530_add-content-table.sql`  (Represents 12:15:30 AM on 8 June 2025 in Brisbane—even though it's still 7 June UTC.)
- `20251201133003_create-users.sql`

### How to generate

```bash
# Option 1 – Supabase CLI (uses your system TZ)
supabase migration new "<description>"

# Option 2 – Manual (force Brisbane TZ explicitly)
timestamp=$(TZ=Australia/Brisbane date +"%Y%m%d%H%M%S")
touch "supabase/migrations/${timestamp}_<description>.sql"
```

⚠️ Never guess or reuse timestamps—always fetch the current Brisbane time programmatically.
